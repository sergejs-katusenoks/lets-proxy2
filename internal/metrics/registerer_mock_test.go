package metrics

// Code generated by http://github.com/gojuno/minimock (3.0.6). DO NOT EDIT.

//go:generate minimock -i github.com/prometheus/client_golang/prometheus.Registerer -o ./registerer_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_prometheus "github.com/prometheus/client_golang/prometheus"
)

// RegistererMock implements prometheus.Registerer
type RegistererMock struct {
	t minimock.Tester

	funcMustRegister          func(p1 ...mm_prometheus.Collector)
	inspectFuncMustRegister   func(p1 ...mm_prometheus.Collector)
	afterMustRegisterCounter  uint64
	beforeMustRegisterCounter uint64
	MustRegisterMock          mRegistererMockMustRegister

	funcRegister          func(c1 mm_prometheus.Collector) (err error)
	inspectFuncRegister   func(c1 mm_prometheus.Collector)
	afterRegisterCounter  uint64
	beforeRegisterCounter uint64
	RegisterMock          mRegistererMockRegister

	funcUnregister          func(c1 mm_prometheus.Collector) (b1 bool)
	inspectFuncUnregister   func(c1 mm_prometheus.Collector)
	afterUnregisterCounter  uint64
	beforeUnregisterCounter uint64
	UnregisterMock          mRegistererMockUnregister
}

// NewRegistererMock returns a mock for prometheus.Registerer
func NewRegistererMock(t minimock.Tester) *RegistererMock {
	m := &RegistererMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.MustRegisterMock = mRegistererMockMustRegister{mock: m}
	m.MustRegisterMock.callArgs = []*RegistererMockMustRegisterParams{}

	m.RegisterMock = mRegistererMockRegister{mock: m}
	m.RegisterMock.callArgs = []*RegistererMockRegisterParams{}

	m.UnregisterMock = mRegistererMockUnregister{mock: m}
	m.UnregisterMock.callArgs = []*RegistererMockUnregisterParams{}

	return m
}

type mRegistererMockMustRegister struct {
	mock               *RegistererMock
	defaultExpectation *RegistererMockMustRegisterExpectation
	expectations       []*RegistererMockMustRegisterExpectation

	callArgs []*RegistererMockMustRegisterParams
	mutex    sync.RWMutex
}

// RegistererMockMustRegisterExpectation specifies expectation struct of the Registerer.MustRegister
type RegistererMockMustRegisterExpectation struct {
	mock   *RegistererMock
	params *RegistererMockMustRegisterParams

	Counter uint64
}

// RegistererMockMustRegisterParams contains parameters of the Registerer.MustRegister
type RegistererMockMustRegisterParams struct {
	p1 []mm_prometheus.Collector
}

// Expect sets up expected params for Registerer.MustRegister
func (mmMustRegister *mRegistererMockMustRegister) Expect(p1 ...mm_prometheus.Collector) *mRegistererMockMustRegister {
	if mmMustRegister.mock.funcMustRegister != nil {
		mmMustRegister.mock.t.Fatalf("RegistererMock.MustRegister mock is already set by Set")
	}

	if mmMustRegister.defaultExpectation == nil {
		mmMustRegister.defaultExpectation = &RegistererMockMustRegisterExpectation{}
	}

	mmMustRegister.defaultExpectation.params = &RegistererMockMustRegisterParams{p1}
	for _, e := range mmMustRegister.expectations {
		if minimock.Equal(e.params, mmMustRegister.defaultExpectation.params) {
			mmMustRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMustRegister.defaultExpectation.params)
		}
	}

	return mmMustRegister
}

// Inspect accepts an inspector function that has same arguments as the Registerer.MustRegister
func (mmMustRegister *mRegistererMockMustRegister) Inspect(f func(p1 ...mm_prometheus.Collector)) *mRegistererMockMustRegister {
	if mmMustRegister.mock.inspectFuncMustRegister != nil {
		mmMustRegister.mock.t.Fatalf("Inspect function is already set for RegistererMock.MustRegister")
	}

	mmMustRegister.mock.inspectFuncMustRegister = f

	return mmMustRegister
}

// Return sets up results that will be returned by Registerer.MustRegister
func (mmMustRegister *mRegistererMockMustRegister) Return() *RegistererMock {
	if mmMustRegister.mock.funcMustRegister != nil {
		mmMustRegister.mock.t.Fatalf("RegistererMock.MustRegister mock is already set by Set")
	}

	if mmMustRegister.defaultExpectation == nil {
		mmMustRegister.defaultExpectation = &RegistererMockMustRegisterExpectation{mock: mmMustRegister.mock}
	}

	return mmMustRegister.mock
}

//Set uses given function f to mock the Registerer.MustRegister method
func (mmMustRegister *mRegistererMockMustRegister) Set(f func(p1 ...mm_prometheus.Collector)) *RegistererMock {
	if mmMustRegister.defaultExpectation != nil {
		mmMustRegister.mock.t.Fatalf("Default expectation is already set for the Registerer.MustRegister method")
	}

	if len(mmMustRegister.expectations) > 0 {
		mmMustRegister.mock.t.Fatalf("Some expectations are already set for the Registerer.MustRegister method")
	}

	mmMustRegister.mock.funcMustRegister = f
	return mmMustRegister.mock
}

// MustRegister implements prometheus.Registerer
func (mmMustRegister *RegistererMock) MustRegister(p1 ...mm_prometheus.Collector) {
	mm_atomic.AddUint64(&mmMustRegister.beforeMustRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmMustRegister.afterMustRegisterCounter, 1)

	if mmMustRegister.inspectFuncMustRegister != nil {
		mmMustRegister.inspectFuncMustRegister(p1...)
	}

	mm_params := &RegistererMockMustRegisterParams{p1}

	// Record call args
	mmMustRegister.MustRegisterMock.mutex.Lock()
	mmMustRegister.MustRegisterMock.callArgs = append(mmMustRegister.MustRegisterMock.callArgs, mm_params)
	mmMustRegister.MustRegisterMock.mutex.Unlock()

	for _, e := range mmMustRegister.MustRegisterMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmMustRegister.MustRegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMustRegister.MustRegisterMock.defaultExpectation.Counter, 1)
		mm_want := mmMustRegister.MustRegisterMock.defaultExpectation.params
		mm_got := RegistererMockMustRegisterParams{p1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMustRegister.t.Errorf("RegistererMock.MustRegister got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmMustRegister.funcMustRegister != nil {
		mmMustRegister.funcMustRegister(p1...)
		return
	}
	mmMustRegister.t.Fatalf("Unexpected call to RegistererMock.MustRegister. %v", p1)

}

// MustRegisterAfterCounter returns a count of finished RegistererMock.MustRegister invocations
func (mmMustRegister *RegistererMock) MustRegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMustRegister.afterMustRegisterCounter)
}

// MustRegisterBeforeCounter returns a count of RegistererMock.MustRegister invocations
func (mmMustRegister *RegistererMock) MustRegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMustRegister.beforeMustRegisterCounter)
}

// Calls returns a list of arguments used in each call to RegistererMock.MustRegister.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMustRegister *mRegistererMockMustRegister) Calls() []*RegistererMockMustRegisterParams {
	mmMustRegister.mutex.RLock()

	argCopy := make([]*RegistererMockMustRegisterParams, len(mmMustRegister.callArgs))
	copy(argCopy, mmMustRegister.callArgs)

	mmMustRegister.mutex.RUnlock()

	return argCopy
}

// MinimockMustRegisterDone returns true if the count of the MustRegister invocations corresponds
// the number of defined expectations
func (m *RegistererMock) MinimockMustRegisterDone() bool {
	for _, e := range m.MustRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MustRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMustRegisterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMustRegister != nil && mm_atomic.LoadUint64(&m.afterMustRegisterCounter) < 1 {
		return false
	}
	return true
}

// MinimockMustRegisterInspect logs each unmet expectation
func (m *RegistererMock) MinimockMustRegisterInspect() {
	for _, e := range m.MustRegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistererMock.MustRegister with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MustRegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMustRegisterCounter) < 1 {
		if m.MustRegisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RegistererMock.MustRegister")
		} else {
			m.t.Errorf("Expected call to RegistererMock.MustRegister with params: %#v", *m.MustRegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMustRegister != nil && mm_atomic.LoadUint64(&m.afterMustRegisterCounter) < 1 {
		m.t.Error("Expected call to RegistererMock.MustRegister")
	}
}

type mRegistererMockRegister struct {
	mock               *RegistererMock
	defaultExpectation *RegistererMockRegisterExpectation
	expectations       []*RegistererMockRegisterExpectation

	callArgs []*RegistererMockRegisterParams
	mutex    sync.RWMutex
}

// RegistererMockRegisterExpectation specifies expectation struct of the Registerer.Register
type RegistererMockRegisterExpectation struct {
	mock    *RegistererMock
	params  *RegistererMockRegisterParams
	results *RegistererMockRegisterResults
	Counter uint64
}

// RegistererMockRegisterParams contains parameters of the Registerer.Register
type RegistererMockRegisterParams struct {
	c1 mm_prometheus.Collector
}

// RegistererMockRegisterResults contains results of the Registerer.Register
type RegistererMockRegisterResults struct {
	err error
}

// Expect sets up expected params for Registerer.Register
func (mmRegister *mRegistererMockRegister) Expect(c1 mm_prometheus.Collector) *mRegistererMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("RegistererMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &RegistererMockRegisterExpectation{}
	}

	mmRegister.defaultExpectation.params = &RegistererMockRegisterParams{c1}
	for _, e := range mmRegister.expectations {
		if minimock.Equal(e.params, mmRegister.defaultExpectation.params) {
			mmRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegister.defaultExpectation.params)
		}
	}

	return mmRegister
}

// Inspect accepts an inspector function that has same arguments as the Registerer.Register
func (mmRegister *mRegistererMockRegister) Inspect(f func(c1 mm_prometheus.Collector)) *mRegistererMockRegister {
	if mmRegister.mock.inspectFuncRegister != nil {
		mmRegister.mock.t.Fatalf("Inspect function is already set for RegistererMock.Register")
	}

	mmRegister.mock.inspectFuncRegister = f

	return mmRegister
}

// Return sets up results that will be returned by Registerer.Register
func (mmRegister *mRegistererMockRegister) Return(err error) *RegistererMock {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("RegistererMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &RegistererMockRegisterExpectation{mock: mmRegister.mock}
	}
	mmRegister.defaultExpectation.results = &RegistererMockRegisterResults{err}
	return mmRegister.mock
}

//Set uses given function f to mock the Registerer.Register method
func (mmRegister *mRegistererMockRegister) Set(f func(c1 mm_prometheus.Collector) (err error)) *RegistererMock {
	if mmRegister.defaultExpectation != nil {
		mmRegister.mock.t.Fatalf("Default expectation is already set for the Registerer.Register method")
	}

	if len(mmRegister.expectations) > 0 {
		mmRegister.mock.t.Fatalf("Some expectations are already set for the Registerer.Register method")
	}

	mmRegister.mock.funcRegister = f
	return mmRegister.mock
}

// When sets expectation for the Registerer.Register which will trigger the result defined by the following
// Then helper
func (mmRegister *mRegistererMockRegister) When(c1 mm_prometheus.Collector) *RegistererMockRegisterExpectation {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("RegistererMock.Register mock is already set by Set")
	}

	expectation := &RegistererMockRegisterExpectation{
		mock:   mmRegister.mock,
		params: &RegistererMockRegisterParams{c1},
	}
	mmRegister.expectations = append(mmRegister.expectations, expectation)
	return expectation
}

// Then sets up Registerer.Register return parameters for the expectation previously defined by the When method
func (e *RegistererMockRegisterExpectation) Then(err error) *RegistererMock {
	e.results = &RegistererMockRegisterResults{err}
	return e.mock
}

// Register implements prometheus.Registerer
func (mmRegister *RegistererMock) Register(c1 mm_prometheus.Collector) (err error) {
	mm_atomic.AddUint64(&mmRegister.beforeRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegister.afterRegisterCounter, 1)

	if mmRegister.inspectFuncRegister != nil {
		mmRegister.inspectFuncRegister(c1)
	}

	mm_params := &RegistererMockRegisterParams{c1}

	// Record call args
	mmRegister.RegisterMock.mutex.Lock()
	mmRegister.RegisterMock.callArgs = append(mmRegister.RegisterMock.callArgs, mm_params)
	mmRegister.RegisterMock.mutex.Unlock()

	for _, e := range mmRegister.RegisterMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRegister.RegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegister.RegisterMock.defaultExpectation.Counter, 1)
		mm_want := mmRegister.RegisterMock.defaultExpectation.params
		mm_got := RegistererMockRegisterParams{c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegister.t.Errorf("RegistererMock.Register got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegister.RegisterMock.defaultExpectation.results
		if mm_results == nil {
			mmRegister.t.Fatal("No results are set for the RegistererMock.Register")
		}
		return (*mm_results).err
	}
	if mmRegister.funcRegister != nil {
		return mmRegister.funcRegister(c1)
	}
	mmRegister.t.Fatalf("Unexpected call to RegistererMock.Register. %v", c1)
	return
}

// RegisterAfterCounter returns a count of finished RegistererMock.Register invocations
func (mmRegister *RegistererMock) RegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.afterRegisterCounter)
}

// RegisterBeforeCounter returns a count of RegistererMock.Register invocations
func (mmRegister *RegistererMock) RegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.beforeRegisterCounter)
}

// Calls returns a list of arguments used in each call to RegistererMock.Register.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegister *mRegistererMockRegister) Calls() []*RegistererMockRegisterParams {
	mmRegister.mutex.RLock()

	argCopy := make([]*RegistererMockRegisterParams, len(mmRegister.callArgs))
	copy(argCopy, mmRegister.callArgs)

	mmRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterDone returns true if the count of the Register invocations corresponds
// the number of defined expectations
func (m *RegistererMock) MinimockRegisterDone() bool {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		return false
	}
	return true
}

// MinimockRegisterInspect logs each unmet expectation
func (m *RegistererMock) MinimockRegisterInspect() {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistererMock.Register with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		if m.RegisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RegistererMock.Register")
		} else {
			m.t.Errorf("Expected call to RegistererMock.Register with params: %#v", *m.RegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && mm_atomic.LoadUint64(&m.afterRegisterCounter) < 1 {
		m.t.Error("Expected call to RegistererMock.Register")
	}
}

type mRegistererMockUnregister struct {
	mock               *RegistererMock
	defaultExpectation *RegistererMockUnregisterExpectation
	expectations       []*RegistererMockUnregisterExpectation

	callArgs []*RegistererMockUnregisterParams
	mutex    sync.RWMutex
}

// RegistererMockUnregisterExpectation specifies expectation struct of the Registerer.Unregister
type RegistererMockUnregisterExpectation struct {
	mock    *RegistererMock
	params  *RegistererMockUnregisterParams
	results *RegistererMockUnregisterResults
	Counter uint64
}

// RegistererMockUnregisterParams contains parameters of the Registerer.Unregister
type RegistererMockUnregisterParams struct {
	c1 mm_prometheus.Collector
}

// RegistererMockUnregisterResults contains results of the Registerer.Unregister
type RegistererMockUnregisterResults struct {
	b1 bool
}

// Expect sets up expected params for Registerer.Unregister
func (mmUnregister *mRegistererMockUnregister) Expect(c1 mm_prometheus.Collector) *mRegistererMockUnregister {
	if mmUnregister.mock.funcUnregister != nil {
		mmUnregister.mock.t.Fatalf("RegistererMock.Unregister mock is already set by Set")
	}

	if mmUnregister.defaultExpectation == nil {
		mmUnregister.defaultExpectation = &RegistererMockUnregisterExpectation{}
	}

	mmUnregister.defaultExpectation.params = &RegistererMockUnregisterParams{c1}
	for _, e := range mmUnregister.expectations {
		if minimock.Equal(e.params, mmUnregister.defaultExpectation.params) {
			mmUnregister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnregister.defaultExpectation.params)
		}
	}

	return mmUnregister
}

// Inspect accepts an inspector function that has same arguments as the Registerer.Unregister
func (mmUnregister *mRegistererMockUnregister) Inspect(f func(c1 mm_prometheus.Collector)) *mRegistererMockUnregister {
	if mmUnregister.mock.inspectFuncUnregister != nil {
		mmUnregister.mock.t.Fatalf("Inspect function is already set for RegistererMock.Unregister")
	}

	mmUnregister.mock.inspectFuncUnregister = f

	return mmUnregister
}

// Return sets up results that will be returned by Registerer.Unregister
func (mmUnregister *mRegistererMockUnregister) Return(b1 bool) *RegistererMock {
	if mmUnregister.mock.funcUnregister != nil {
		mmUnregister.mock.t.Fatalf("RegistererMock.Unregister mock is already set by Set")
	}

	if mmUnregister.defaultExpectation == nil {
		mmUnregister.defaultExpectation = &RegistererMockUnregisterExpectation{mock: mmUnregister.mock}
	}
	mmUnregister.defaultExpectation.results = &RegistererMockUnregisterResults{b1}
	return mmUnregister.mock
}

//Set uses given function f to mock the Registerer.Unregister method
func (mmUnregister *mRegistererMockUnregister) Set(f func(c1 mm_prometheus.Collector) (b1 bool)) *RegistererMock {
	if mmUnregister.defaultExpectation != nil {
		mmUnregister.mock.t.Fatalf("Default expectation is already set for the Registerer.Unregister method")
	}

	if len(mmUnregister.expectations) > 0 {
		mmUnregister.mock.t.Fatalf("Some expectations are already set for the Registerer.Unregister method")
	}

	mmUnregister.mock.funcUnregister = f
	return mmUnregister.mock
}

// When sets expectation for the Registerer.Unregister which will trigger the result defined by the following
// Then helper
func (mmUnregister *mRegistererMockUnregister) When(c1 mm_prometheus.Collector) *RegistererMockUnregisterExpectation {
	if mmUnregister.mock.funcUnregister != nil {
		mmUnregister.mock.t.Fatalf("RegistererMock.Unregister mock is already set by Set")
	}

	expectation := &RegistererMockUnregisterExpectation{
		mock:   mmUnregister.mock,
		params: &RegistererMockUnregisterParams{c1},
	}
	mmUnregister.expectations = append(mmUnregister.expectations, expectation)
	return expectation
}

// Then sets up Registerer.Unregister return parameters for the expectation previously defined by the When method
func (e *RegistererMockUnregisterExpectation) Then(b1 bool) *RegistererMock {
	e.results = &RegistererMockUnregisterResults{b1}
	return e.mock
}

// Unregister implements prometheus.Registerer
func (mmUnregister *RegistererMock) Unregister(c1 mm_prometheus.Collector) (b1 bool) {
	mm_atomic.AddUint64(&mmUnregister.beforeUnregisterCounter, 1)
	defer mm_atomic.AddUint64(&mmUnregister.afterUnregisterCounter, 1)

	if mmUnregister.inspectFuncUnregister != nil {
		mmUnregister.inspectFuncUnregister(c1)
	}

	mm_params := &RegistererMockUnregisterParams{c1}

	// Record call args
	mmUnregister.UnregisterMock.mutex.Lock()
	mmUnregister.UnregisterMock.callArgs = append(mmUnregister.UnregisterMock.callArgs, mm_params)
	mmUnregister.UnregisterMock.mutex.Unlock()

	for _, e := range mmUnregister.UnregisterMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUnregister.UnregisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnregister.UnregisterMock.defaultExpectation.Counter, 1)
		mm_want := mmUnregister.UnregisterMock.defaultExpectation.params
		mm_got := RegistererMockUnregisterParams{c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnregister.t.Errorf("RegistererMock.Unregister got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnregister.UnregisterMock.defaultExpectation.results
		if mm_results == nil {
			mmUnregister.t.Fatal("No results are set for the RegistererMock.Unregister")
		}
		return (*mm_results).b1
	}
	if mmUnregister.funcUnregister != nil {
		return mmUnregister.funcUnregister(c1)
	}
	mmUnregister.t.Fatalf("Unexpected call to RegistererMock.Unregister. %v", c1)
	return
}

// UnregisterAfterCounter returns a count of finished RegistererMock.Unregister invocations
func (mmUnregister *RegistererMock) UnregisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnregister.afterUnregisterCounter)
}

// UnregisterBeforeCounter returns a count of RegistererMock.Unregister invocations
func (mmUnregister *RegistererMock) UnregisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnregister.beforeUnregisterCounter)
}

// Calls returns a list of arguments used in each call to RegistererMock.Unregister.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnregister *mRegistererMockUnregister) Calls() []*RegistererMockUnregisterParams {
	mmUnregister.mutex.RLock()

	argCopy := make([]*RegistererMockUnregisterParams, len(mmUnregister.callArgs))
	copy(argCopy, mmUnregister.callArgs)

	mmUnregister.mutex.RUnlock()

	return argCopy
}

// MinimockUnregisterDone returns true if the count of the Unregister invocations corresponds
// the number of defined expectations
func (m *RegistererMock) MinimockUnregisterDone() bool {
	for _, e := range m.UnregisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnregisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnregisterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnregister != nil && mm_atomic.LoadUint64(&m.afterUnregisterCounter) < 1 {
		return false
	}
	return true
}

// MinimockUnregisterInspect logs each unmet expectation
func (m *RegistererMock) MinimockUnregisterInspect() {
	for _, e := range m.UnregisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RegistererMock.Unregister with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnregisterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnregisterCounter) < 1 {
		if m.UnregisterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RegistererMock.Unregister")
		} else {
			m.t.Errorf("Expected call to RegistererMock.Unregister with params: %#v", *m.UnregisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnregister != nil && mm_atomic.LoadUint64(&m.afterUnregisterCounter) < 1 {
		m.t.Error("Expected call to RegistererMock.Unregister")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RegistererMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockMustRegisterInspect()

		m.MinimockRegisterInspect()

		m.MinimockUnregisterInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RegistererMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RegistererMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockMustRegisterDone() &&
		m.MinimockRegisterDone() &&
		m.MinimockUnregisterDone()
}
