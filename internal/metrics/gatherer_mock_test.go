package metrics

// Code generated by http://github.com/gojuno/minimock (3.0.6). DO NOT EDIT.

//go:generate minimock -i github.com/prometheus/client_golang/prometheus.Gatherer -o ./gatherer_mock_test.go

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	dto "github.com/prometheus/client_model/go"
)

// GathererMock implements prometheus.Gatherer
type GathererMock struct {
	t minimock.Tester

	funcGather          func() (mpa1 []*dto.MetricFamily, err error)
	inspectFuncGather   func()
	afterGatherCounter  uint64
	beforeGatherCounter uint64
	GatherMock          mGathererMockGather
}

// NewGathererMock returns a mock for prometheus.Gatherer
func NewGathererMock(t minimock.Tester) *GathererMock {
	m := &GathererMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GatherMock = mGathererMockGather{mock: m}

	return m
}

type mGathererMockGather struct {
	mock               *GathererMock
	defaultExpectation *GathererMockGatherExpectation
	expectations       []*GathererMockGatherExpectation
}

// GathererMockGatherExpectation specifies expectation struct of the Gatherer.Gather
type GathererMockGatherExpectation struct {
	mock *GathererMock

	results *GathererMockGatherResults
	Counter uint64
}

// GathererMockGatherResults contains results of the Gatherer.Gather
type GathererMockGatherResults struct {
	mpa1 []*dto.MetricFamily
	err  error
}

// Expect sets up expected params for Gatherer.Gather
func (mmGather *mGathererMockGather) Expect() *mGathererMockGather {
	if mmGather.mock.funcGather != nil {
		mmGather.mock.t.Fatalf("GathererMock.Gather mock is already set by Set")
	}

	if mmGather.defaultExpectation == nil {
		mmGather.defaultExpectation = &GathererMockGatherExpectation{}
	}

	return mmGather
}

// Inspect accepts an inspector function that has same arguments as the Gatherer.Gather
func (mmGather *mGathererMockGather) Inspect(f func()) *mGathererMockGather {
	if mmGather.mock.inspectFuncGather != nil {
		mmGather.mock.t.Fatalf("Inspect function is already set for GathererMock.Gather")
	}

	mmGather.mock.inspectFuncGather = f

	return mmGather
}

// Return sets up results that will be returned by Gatherer.Gather
func (mmGather *mGathererMockGather) Return(mpa1 []*dto.MetricFamily, err error) *GathererMock {
	if mmGather.mock.funcGather != nil {
		mmGather.mock.t.Fatalf("GathererMock.Gather mock is already set by Set")
	}

	if mmGather.defaultExpectation == nil {
		mmGather.defaultExpectation = &GathererMockGatherExpectation{mock: mmGather.mock}
	}
	mmGather.defaultExpectation.results = &GathererMockGatherResults{mpa1, err}
	return mmGather.mock
}

//Set uses given function f to mock the Gatherer.Gather method
func (mmGather *mGathererMockGather) Set(f func() (mpa1 []*dto.MetricFamily, err error)) *GathererMock {
	if mmGather.defaultExpectation != nil {
		mmGather.mock.t.Fatalf("Default expectation is already set for the Gatherer.Gather method")
	}

	if len(mmGather.expectations) > 0 {
		mmGather.mock.t.Fatalf("Some expectations are already set for the Gatherer.Gather method")
	}

	mmGather.mock.funcGather = f
	return mmGather.mock
}

// Gather implements prometheus.Gatherer
func (mmGather *GathererMock) Gather() (mpa1 []*dto.MetricFamily, err error) {
	mm_atomic.AddUint64(&mmGather.beforeGatherCounter, 1)
	defer mm_atomic.AddUint64(&mmGather.afterGatherCounter, 1)

	if mmGather.inspectFuncGather != nil {
		mmGather.inspectFuncGather()
	}

	if mmGather.GatherMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGather.GatherMock.defaultExpectation.Counter, 1)

		mm_results := mmGather.GatherMock.defaultExpectation.results
		if mm_results == nil {
			mmGather.t.Fatal("No results are set for the GathererMock.Gather")
		}
		return (*mm_results).mpa1, (*mm_results).err
	}
	if mmGather.funcGather != nil {
		return mmGather.funcGather()
	}
	mmGather.t.Fatalf("Unexpected call to GathererMock.Gather.")
	return
}

// GatherAfterCounter returns a count of finished GathererMock.Gather invocations
func (mmGather *GathererMock) GatherAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGather.afterGatherCounter)
}

// GatherBeforeCounter returns a count of GathererMock.Gather invocations
func (mmGather *GathererMock) GatherBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGather.beforeGatherCounter)
}

// MinimockGatherDone returns true if the count of the Gather invocations corresponds
// the number of defined expectations
func (m *GathererMock) MinimockGatherDone() bool {
	for _, e := range m.GatherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GatherMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGatherCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGather != nil && mm_atomic.LoadUint64(&m.afterGatherCounter) < 1 {
		return false
	}
	return true
}

// MinimockGatherInspect logs each unmet expectation
func (m *GathererMock) MinimockGatherInspect() {
	for _, e := range m.GatherMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GathererMock.Gather")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GatherMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGatherCounter) < 1 {
		m.t.Error("Expected call to GathererMock.Gather")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGather != nil && mm_atomic.LoadUint64(&m.afterGatherCounter) < 1 {
		m.t.Error("Expected call to GathererMock.Gather")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GathererMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGatherInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GathererMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GathererMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGatherDone()
}
